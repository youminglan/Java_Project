### 图书管理系统

#### 技术栈

- Freemaker

  Freemaker是用来代替JSP的模板渲染工具，用来将Model中的数据渲染到View上。

- Web 

  Web组件的本质就是SpringMVC。用来控制整个MVC主体流程。

- My Batis

  负责与数据库交互

- Aspect

  Spring中重要的AOP组件，用来面向切面编程，多用在日志打印、权限认证等地方。

#### 项目目录

- static：用来存放一系列静态文件，比如css、font、img、js。
- templates：存放html文件以及模板文件
- application.properties：Spring Boot的配置文件
- log4j.properties：log4的配置文件
- mybatis-config.xml：MyBatis的配置文件。一般不做改动
- BookManagermentApplication.java：Spring Boot的入口

##### 自己创建的目录

- biz：存放比较复杂的逻辑

- configuration：存放Spring Boot的代码配置

- controllers：存放控制器，是"网页的入口"

- dao：存放与数据库交互的包，主要是MyBatis

- interceptor：AOP的代码

- model：各种数据模型，对数据的描述

- service：用作对dao层的封装

- utils：工具包，一般是静态方法

  

#### 图书的增删改查

- model包

  1. Book.java

     ```java
     private int id;
     
     private String name;
     
     private String author;
     
     Private String price;
     ```

- dao包

  1. BookDAO.java
  
     ```java
     @Insert({"insert into", table_name, "(", insert_field, ") values (#{name},#{author},#{price})"})
     int addBook(Book book);
     
     String table_name = "book";
     String insert_field = "name, author, price";
     String insert_field = "id, status, "+ insert field;
     
     //如果想要通过书的id和name查询一本书
     Book selectBookById(int id);
     
     Book selectBookByName(int name);
     ```

- service包

  **service包的BookService.java对BookDao.java做一些封装，可以将其理解为"代理"**

  在BookService.java中，首先有一个BookDAO对象，这个对象由Spring自动帮你注入（@Autowired），不用亲自去实例化。现在需要将BookDAO的方法“包装”一下以供上层的类去调用。

  作用：

  1. 分层：将一些功能统一处理

     ```java
     public List<Book> getAllBooks(){
         try{
             return bookDAO.selectALL();
         }catch(Exception e){
             logger.errors(e);
             return null;
             /*抛出异常*/
         }
     }
     ```

     所有异常都在service层被处理掉了，并记录在了log中，上层调用的时候再也不用关心底层的异常问题。

     注：异常需要说一句，千万不要静默的吞掉异常（就是在catch里面什么都不做，后者返回一个假数据），不然排查问题的时候你将无从下手，如果你不知道怎么处理异常又非处理不可的时候，至少先将异常记录在日志中吧！

  2. 多态、封装、重载

     很显然多了一层你可以干更多的事情，而且能将DAO层的方法封装的更优雅一点，以至于上层完全不知道你在跟数据库打交道。而且你可以有更多的操作空间，比如：

     ```java
     //在BookDAO.java中有如下两个方法根据不同的条件查询一本书
     Book selectBookById(int id);
     Book selecrBookByName(int name);
     
     //在对应的BookService.java中可以这么写
     Book getBook(int id){ return bookDAO.selectBookById(id);};
     Book getBook(int name){ return bookDAO.selectBookByName(name);}
     ```

     问：可以发现好不容易在DAO层用不用的命名将不同的查询方法区分开，而在Service层中又合并成了一个重载的方法名称getBook，那为什么不在DAO层就重载呢

     答：DAO层关心的就是跟数据库打交道，这样所有的方法名都应该要尽量的去描述自己的功能；

     而Service层关心的是功能根据Name也好还是根据id也好在上层来看并没有区别，都是给我去取一本书来，我不用管你是根据书的什么属性去取。

- Controller

  1. BookController.java

     ```java
     @RequestMapping(path = {"/index"}, method = {RequestMethod.GET})
     public String bookList(Model model){
         loadAllBookView(model);
         return "book/books";
     }
     ```

     上面代码为我们展示的MVC框架：

     1. 第一行告诉web什么样的url才能进入这个方法
     2. loadAllBookView(model)告诉web如何处理和组装Model
     3. return "book/books"告诉web返回什么样的View
     4. 这整段代码整体就是一个控制器Controller，它控制了怎么进入、怎么处理、怎么返回的所有操作

  注： return "book/books"; 这句，return到哪去了？

  在resources/templates包下里面的book/books.html



- application.properties

  我们在里面添加了一些内容，数据库的部分很简单，相信大家能看明白，

```
spring.freemarker.suffix=.html
```

​	这一句呢，作用就是让我们能保持习惯，将templates文件夹下的模板文件以.html结尾


#### 增加用户User和T票Ticket