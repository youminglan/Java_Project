1. 类与对象的区别？

   类是对一类对象具有相同属性和行为的一种抽象；对象是类的实例化。

   车这个抽象概念，马路上很多车，无法具体到哪一辆，特指的某辆车就是一个对象

2. static和final

   static静态修饰符可以修饰代码块，变量和类方法。

   当修饰代码块时，系统初始化代码块；修饰变量时，JVM会将其分配在内存堆上；修饰类方法时，可以直接通过类调用这个类方法，而不需要new一个对象。

   final修饰符可以修饰变量，方法和类。

   修饰变量时，程序不可以改变变量的值；修饰方法时，其子类不能重写方法；修饰类时，该类不能被继承。

3. 接口与抽象类的区别

   相同：都不能被实例化

   不同：接口只能定义，不能有方法的实现，抽象类可以有方法的实现；一个类可以实现多个接口，但一个类只能实现一个抽象类。

4. object类

   所有类都继承自object类实例化方法

   有clone、toString、hashCode方法

5. 创建线程几种方式

   继承Thread类；实现runnable接口

6. 设计模式

   单例模式、工厂方法模式、抽象工厂模式、桥接模式

7. 面向对象特性

   封装、继承、多态

8. String、StringBuffer、StringBuilder区别

   String：字符串，一旦赋值就不能改变；

   StringBuffer：线程安全的可变字节，可以作为字符串拼接，不会浪费太多资源

   StringBuilder：数据不安全，但效率高

9. Integer与int的区别

   Integer是int的包装类，int是基本数据类型；Integer必须被实例化，实际上是对象的引用

10. 集合框架有哪些？

    Map、List、Set

11. 线程与进程的区别

    进程是一个程序从开始到消亡的过程，线程是进程中独立的执行序列。一个进程包含多个线程。

12. 垃圾回收

    垃圾回收通过垃圾收集器把内存中没用的对象清理掉。

13. 垃圾回收算法

    标记清除算法、复制算法、标记整理算法、分化收集算法

14. 有哪些锁

    乐观锁，悲观锁、公平锁，非公平锁、独占锁、共享锁。

15. 深拷贝和浅拷贝

    深拷贝：对基本数据类型进行值传递；对引用数据类型，创建一个新的对象，并复制其内容

    浅拷贝：对基本数据类型进行值传递；对引用数据类型进行引用传递般的拷贝

16. 死锁原因以及如何避免死锁

    多个线程同时被堵塞，它们中的一个或者全部都在等待某个资源被释放

    解决办法：破坏互斥条件，破坏请求与保持条件，破坏循环等待条件

17. 重写与重载

    重写是子类对父类的允许访问方法的实现过程进行重新编写。发生在子类中，方法名、参数相同

    重载是在同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。发生在同一个类中，方法名相同，参数，返回值可以不同。

19. 自动装箱和拆箱

    装箱：将基本数据类型用它们对应的引用类型包装起来

    拆箱：将包装类型转换为基本数据类型

20. ==与equals

    ==比较两个对象是否相同(内存地址是否相同)

    类没覆盖equals方法：等价于"=="；类覆盖equals方法：比较对象内容是否相等

21. hashCode和equals

    重写的equals里一般是复杂的比较，效率比较低

    用hashCode比较的是对象在哈希表中索引位置是否相同，只需生成一个hash值进行比较就可以了

21. 为什么重写equals时必须重写hashCode

    1、如果两个对象相同（即equals返回true） ，hashcode一定相等；但是hashcod相等时，两个对象却不一定equals 2、由于为了提高程序的执行效率才实现了hashcode方法，先进行hashcode比较，如果不同，就没有必要进行equals比较了，这样就大大的减少了equals的使用次数，从而效率得到提高

22. redis的基本数据类型

    string、hash、set、zset、list

23. UDP 和 TCP 的特点与区别

    UDP（用户数据报协议）无连接的，尽最大可能交付，没有拥塞控制，面向报文。

    TCP（传输控制协议）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流

24. Linux命令

    cd 用于切换当前目录

    ls 查看文件与目录的命令

    mkdir 创建指定的名称的目录

    mv 移动文件、目录或更名

    rm 删除文件或目录

25. 说一下为什么要使用Spring Boot

    容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。
    开箱即用，远离繁琐的配置。
    提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。
    没有代码生成，也不需要XML配置。
    避免大量的 Maven 导入和各种版本冲突。

26. Spring Boot 有哪些注解？

    @SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。

    @EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。

    @ComponentScan：Spring组件扫描。

27. 普通方法和构造方法区别
    构造方法：方法名和类名相同；在方法名的前面没有返回值类型的声明；在方法中不能使用return语句返回一个值；在创建对象时，要调用new。

    普通方法：有返回类型( void 或者确定的类型)；方法名不能和类名相同；普通方法是不能new 的，可以通过对象名来调用

28. HTTPS和HTTP的区别

    https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
    http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
    http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
    http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

29. 三次握手

    第一次握手：客户端给服务器发送一个 SYN 报文。

    第二次握手：服务器收到 SYN 报文之后，会应答一个 SYN+ACK 报文。

    第三次握手：客户端收到 SYN+ACK 报文之后，会回应一个 ACK 报文。

30. 三次握手的作用

    确认双方的接收和发送是否正常。

    指定自己的初始化序列号，为后面的可靠传送做准备。

    如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。

31. 什么是BIO，NIO，AIO ？

    BIO：blocking I/O 同步阻塞IO模式，数据的读取写入必须阻塞在一个线程内等待其完成

    NIO： non-blocking IO 同步非阻塞IO，IO面向流，而NIO面向缓冲区，任何时候访问NIO的数据，都是面向缓冲区的，最常用的缓冲区是ByteBuffer

    AIO 即NIO2，异步非阻塞IO模型，基于事件和回调机制实现

32. 说说List,Set,Map三者的区别？

    List (对付顺序的好帮⼿)： 存储的元素是有序的、可重复的。

    Set (注重独⼀⽆⼆的性质): 存储的元素是无序的、不可重复的。

    Map (⽤ Key 来搜索的专家): 使用键值对（kye-value）存储，类似于数学上的函数

    y=f(x)，“x”代表 key，"y"代表 value，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到⼀个值。

33.  Arraylist 与 LinkedList区别？

    Arraylist 底层使⽤的是 Object 数组； LinkedList 底层使⽤的是 双向链表；ArrayList 采用数组存储，而LinkedList采用链表存储

34.  ArrayList 与 Vector区别呢?为什么要用Arraylist取代Vector呢？

    ArrayList 是 List 的主要实现类，底层使⽤ Object[ ] 存储，适⽤于频繁的查找⼯作，线程不安全 ；

    Vector 是 List 的古⽼实现类，底层使⽤ Object[ ] 存储，线程安全的。

35. HashMap 和 HashSet区别？

    HashMap存储键值对实现了 Map 接口，HashSet仅存储对象实现 Set 接⼝

36. HashMap的底层实现

    **数组和链表** 结合在⼀起使⽤也就是 链表散列

37.  集合框架底层数据结构总结

    List：

    Arraylist ： Object[] 数组

    Vector ： Object[] 数组

    LinkedList ： 双向链表

    Set：

    HashSet （⽆序，唯⼀）: 基于 HashMap 

    实现的，底层采用HashMap 来保存元素

    LinkedHashSet ： LinkedHashSet 是 HashSet 的⼦类，并且其内部是通过 LinkedHashMap来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现⼀样，不过还是有⼀点点区别的

    TreeSet （有序，唯⼀）： 红⿊树(⾃平衡的排序⼆叉树)

    **Map**

    HashMap ： JDK1.8 之前 HashMap 

    由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突⽽存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了᫾⼤的变化，当链表⻓度⼤于阈值（默认为 8）（将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树）时，将链表转化为红⿊树，以减少搜索时间

    LinkedHashMap ： LinkedHashMap 继承⾃ HashMap ，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红⿊树组成。另外， LinkedHashMap 在上⾯结构的基础上，增加了⼀条双向链表，使得上⾯的结构可以保持键值对的插⼊顺序。同时通过对链表进⾏相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》

    Hashtable ： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突⽽存在的

    TreeMap ： 红黑树（⾃平衡的排序⼆叉树）

38. 说说并发与并行的区别?

    并发： 同⼀时间段，多个任务都在执行 (单位时间内不⼀定同时执⾏)；

    并⾏：单位时间内，多个任务同时执行。

39. 说出使⽤ Spring Boot 的主要优点？

40. 介绍⼀下@SpringBootApplication 注解？

41. Spring Boot 的⾃动配置是如何实现的?

42. 为什么要使用多线程？

    使⽤多线程⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度。如果多线程使⽤不当，不仅不会提⾼程序的执⾏速度，可能会遇到很多问题，⽐如：线程不安全、内存泄漏、死锁等等。

43. 那你说说造成线程死锁的原因有哪些吧？

    线程死锁描述的是这样⼀种情况：**多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资**

    **源被释放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。**

44. **如何避免线程线程死锁呢****?**

    **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界

    资源需要互斥访问）。

    **破坏请求与保持条件** ：⼀次性申请所有的资源。

    **破坏不剥夺条件** ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释

    放它占有的资源。

    **破坏循环等待条件** ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。
    
45. 封装继承多态

    封装把⼀个对象的属性私有化，同时提供⼀些可以被外界访问的属性的⽅法，如果属性不想被外界访问，我们⼤可不必提供⽅法给外界访问。

     

    继承是使用已存在的类的定义作为基础建⽴新类的技术，新类的定义可以增加新的数据或新的功能，也可以⽤⽗类的功能，但不能选择性地继承⽗类。通过使⽤继承我们能够常⽅便地复⽤以前的代码。

     

    多态就是指程序中定义的引⽤变量所指向的具体类型和通过该引⽤变量发出的⽅法调⽤在编程时并不确定，⽽是在程序运⾏期间才确定，即⼀个引⽤变量到底会指向哪个类的实例对象，该引⽤变量发出的⽅法调⽤到底是哪个类中实现的⽅法，必须在由程序运⾏期间才能决定
    
46. 索引

    MySQL索引使⽤的数据结构主要有**BTree****索引** 和 **哈希索引** 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝⼤多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余⼤部分场景，建议选择BTree索引

47.  什么是事务?

    事务是逻辑上的⼀组操作，要么都执行，要么都不执行。

    事务最经典也经常被拿出来说例⼦就是转账了。假如⼩明要给⼩红转账1000元，这个转账会涉及到两个关键操作就是：将⼩明的余额减少1000元，将⼩红的余额增加1000元。万⼀在这两个操作之间突然出现错误⽐如银⾏系统崩溃，导致⼩明余额减少⽽⼩红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。

48. 什么是数据库连接池?为什么需要数据库连接池?

    数据库连接本质就是⼀个 socket 的连接。数据库服务端还要维护⼀些缓存和⽤户权限信息之类的 所以占用了⼀些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个⽤户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵⼜浪费资源。在连接池中，创建连接后，将其放置在池中，并再次使⽤它，因此不必建立新的连接。如果使用了所有连接，则会建立⼀个新连接并将其添加到池中。 连接池还减少了用户必须等待建立与数据库的连接的时间。

49. 什么是Redis？

    简单来说Redis就是⼀个使⽤C语⾔开发的数据库，不过与传统数据库不同的是 Redis的数据是存在内存中的，也就是它是内存数据库，所以读写速度⾮常快，因此 Redis 被⼴泛应⽤于缓存⽅向。另外，Redis除了做缓存之外，Redis 也经常⽤来做分布式锁，甚⾄是消息队列。Redis提供了多种数据类型来⽀持不同的业务场景。Redis还⽀持事务 、持久化、Lua 脚本、多种集群⽅案。
    
50. 谈谈⾃⼰对于Spring IoC和AOP的理解
    IoC（Inverse of Control:控制反转）是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 IoC容器是Spring⽤来实现IoC的载体，IoC容器实际上就是Map（key，value）,Map中存放的是各种对象。

    AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。
    
51. Spring 框架中⽤到了哪些设计模式？

    **⼯⼚设计模式** : Spring使⽤⼯⼚模式通过 BeanFactory 、 ApplicationContext 创建 bean 对

    象。

    **代理设计模式** : Spring AOP 功能的实现。

    单例设计模式 : Spring 中的 Bean 默认都是单例的。包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。

    观察者模式：Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。

    适配器模式：Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。

52. Cookie和Session有什么区别？

    Cookie 和 Session都是⽤来跟踪浏览器⽤户身份的会话⽅式，但是两者的应⽤场景不太⼀样。Cookie⼀般⽤来保存⽤户信息 ⽐如①我们在 Cookie 中保存已经登录过得⽤户信息，下次访问⽹站的时候⻚⾯可以⾃动帮你登录的⼀些基本信息给填了；②⼀般的⽹站都会有保持登录也就是说下次你再访问⽹站的时候就不需要重新登录了，这是因为⽤户登录的时候我们可以存放了⼀个Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找⽤户即可(为了安全考虑，重新登录⼀般要将 Token 重写)；③登录⼀次⽹站后访问⽹站其他⻚⾯不需要重新登录。Session 的主要作⽤就是通过服务端记录⽤户的状态。典型的场景是购物⻋，当你要添加商品到购物⻋的时候，系统不知道是哪个⽤户操作的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定的 Session 之后就可以标识这个⽤户并且跟踪这个⽤户了。

    Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。
    
    Cookie 存储在客户端中，⽽Session存储在服务器上，相对来说 Session 安全性更⾼。如果要在Cookie 中存储⼀些敏感信息，不要直接写⼊ Cookie 中，最好能将 Cookie 信息加密然后使⽤到的时候再去服务器端解密。
    
53. 为什么要四次挥手

    任何⼀⽅都可以在数据传送结束后发出连接释放的通知，待对⽅确认后进⼊半关闭状态。当另⼀⽅也没有数据再发送的时候，则发出连接释放通知，对⽅确认后就完全关闭了TCP连接。

    举个例⼦：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B可能还会有要说的话，A 不能要求 B 跟着⾃⼰的节奏结束通话，于是 B 可能⼜巴拉巴拉说了⼀通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

54. HTTP和HTTPS的区别？

    1. 端口 ：HTTP的URL由“http://”起始且默认使⽤端⼝80，⽽HTTPS的URL由“https://”起始且默认使⽤端⼝443。

    2. 安全性和资源消耗： HTTP协议运⾏在TCP之上，所有传输的内容都是明⽂，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS⾼，但是 HTTPS 比HTTP耗费更多服务器资源。

55. 使用缓存的目的？

    对于一些经常被查询的数据，若每次都从数据库中获取，则会极大地消耗系统性能，将这些数据放在缓存中，并设置过期时间，查询时若缓存中有值，则从缓存中获取，否则从数据库中获取，并将新值存入缓存。这样可以减轻数据库的访问频率，从而提高系统性能

56. 如何实现限制同一账号登陆人数？

    并发执行时，存在同一个用户在多处同时登陆，此处为了限制只能允许一个人登陆系统，使用 redis 进行辅助。其中 key 为 用户名（或者 ID 值）、 value 为 token 值（JWT 值）。
    用户第一次访问系统时，首先判定是否为第一次登录系统（检查 redis 中是否存在 token），不存在则为第一次登录，需要将 token 存入 redis 中，并将该 token 返回给用户。存在则继续判定是否为重复登录系统（检查 token 是否一致）。token 一致，则为同一用户再次访问系统。token 不一致，则用户为重复登录系统，此时需要剔除前一个登录用户（比较当前 token 与 redis 中 token 的时间戳），如果当前 token 时间戳 大于等于 redis 中 token 时间戳，则当前时间戳为最新登录者，此时剔除 redis 中的 token 数据（即将 当前 token 数据存入 redis），如果 小于 redis 中 token 时间戳，则 redis 中 token 为最新登录者，需剔除当前 token（不返回 token 给用户，即登录失败，引导用户重新登录）。